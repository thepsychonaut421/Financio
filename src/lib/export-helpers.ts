
import type { IncomingInvoiceItem, ERPIncomingInvoiceItem } from '@/types/incoming-invoice';
import { format as formatDateFns, parseISO, isValid } from 'date-fns';

export function downloadFile(content: string, fileName: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function escapeCSVField(field: string | number | undefined | null): string {
  if (field === undefined || field === null) return '';
  const stringField = String(field);
  if (stringField.includes('"') || stringField.includes(',') || stringField.includes('\n') || stringField.includes('\r')) {
    return `"${stringField.replace(/"/g, '""')}"`;
  }
  return stringField;
}

// This function is not directly used by ERPNext export but kept for standard CSV.
function formatDateToMMDDYY(dateString?: string): string {
  if (!dateString) return '';
  try {
    // Assuming dateString is already YYYY-MM-DD from formatDateForERP
    const date = parseISO(dateString); 
    if (isValid(date)) {
      return formatDateFns(date, 'MM/dd/yy');
    }
  } catch (e) { /* ignore */ }
  // Fallback if already in a different format or parsing fails
  return dateString; 
}


export function incomingInvoicesToCSV(invoices: IncomingInvoiceItem[]): string {
  if (!invoices || invoices.length === 0) return '';

  const mainHeaders = [
    'PDF Datei',
    'Rechnungsnummer',
    'Datum', 
    'Lieferant Name',
    'Lieferant Adresse',
    'Zahlungsziel',
    'Zahlungsart',
    'Gesamtbetrag',
    'MwSt-Satz',
    'Kunden-Nr.',
    'Bestell-Nr.'
  ];
  const itemHeaders = ['Pos. Produkt Code', 'Pos. Produkt Name', 'Pos. Menge', 'Pos. Einzelpreis'];
  
  let csvString = mainHeaders.join(',') + ',' + itemHeaders.join(',') + '\n';

  invoices.forEach((invoice) => {
    const mainInvoiceData = [
      escapeCSVField(invoice.pdfFileName),
      escapeCSVField(invoice.rechnungsnummer),
      escapeCSVField(invoice.datum), 
      escapeCSVField(invoice.lieferantName),
      escapeCSVField(invoice.lieferantAdresse),
      escapeCSVField(invoice.zahlungsziel),
      escapeCSVField(invoice.zahlungsart),
      invoice.gesamtbetrag?.toString() ?? '',
      escapeCSVField(invoice.mwstSatz),
      escapeCSVField(invoice.kundenNummer),
      escapeCSVField(invoice.bestellNummer),
    ];

    if (invoice.rechnungspositionen && invoice.rechnungspositionen.length > 0) {
      invoice.rechnungspositionen.forEach(item => {
        const itemData = [
          escapeCSVField(item.productCode),
          escapeCSVField(item.productName),
          item.quantity.toString(),
          item.unitPrice.toString(),
        ];
        csvString += mainInvoiceData.join(',') + ',' + itemData.join(',') + '\n';
      });
    } else {
      // If no items, just write the main invoice data with empty item fields
      const emptyItemData = Array(itemHeaders.length).fill('');
      csvString += mainInvoiceData.join(',') + ',' + emptyItemData.join(',') + '\n'; 
    }
  });

  return csvString;
}


export function incomingInvoicesToERPNextCSVComplete(invoices: ERPIncomingInvoiceItem[]): string {
  if (!invoices || invoices.length === 0) return '';

  // Invoice level headers (excluding ID as it's auto-generated by ERPNext on new record)
  const invoiceHeaders = [
    "supplier", "bill_no", "bill_date", "posting_date", "due_date", 
    "currency", 
    // "credit_to" column is now intentionally left blank based on user feedback
    "is_paid", "remarks", 
    "update_stock", "set_posting_time"
    // naming_series is also removed as ERPNext handles it based on DocType settings
  ];

  // Item level headers, aligned with ERPNext Purchase Invoice Item template
  const itemHeaders = [
    "ID (Items)", // Mapped from item.productCode
    "Item Name (Items)", // Mapped from item.productName
    "Description (Items)", // Can be same as Item Name
    "Accepted Qty (Items)", // Mapped from item.quantity
    "UOM (Items)", // Default "Stk"
    "Rate (Items)", // Mapped from item.unitPrice
    "Amount (Items)", // Calculated: qty * rate
    "Accepted Qty in Stock UOM (Items)", // Default to Accepted Qty
    "UOM Conversion Factor (Items)", // Default 1
    "Amount (Company Currency) (Items)", // Default to Amount (assuming invoice currency is company currency)
    "Rate (Company Currency) (Items)", // Default to Rate
    "Warehouse (Items)", // Placeholder - User to fill
    "Cost Center (Items)", // Placeholder - User to fill
    "Expense Account (Items)", // Placeholder - User to fill
  ];
  
  const allHeaders = [...invoiceHeaders, ...itemHeaders];
  let csvString = allHeaders.map(escapeCSVField).join(',') + '\n';

  invoices.forEach((invoice) => {
    const invoiceLevelData = [
      escapeCSVField(invoice.lieferantName),
      escapeCSVField(invoice.rechnungsnummer), 
      escapeCSVField(invoice.billDate),     
      escapeCSVField(invoice.datum), 
      escapeCSVField(invoice.dueDate),      
      escapeCSVField(invoice.wahrung || 'EUR'),
      // credit_to is now blank: ""
      invoice.istBezahlt?.toString() ?? '0',
      escapeCSVField(invoice.remarks),
      '1', // update_stock (default)
      '1', // set_posting_time (default)
    ];

    if (invoice.rechnungspositionen && invoice.rechnungspositionen.length > 0) {
      invoice.rechnungspositionen.forEach(item => {
        const itemAmount = (item.quantity || 0) * (item.unitPrice || 0);
        const itemData = [
          escapeCSVField(item.productCode),                 
          escapeCSVField(item.productName),                 
          escapeCSVField(item.productName),                 
          item.quantity?.toString() ?? '0',                 
          "Stk",                                            
          item.unitPrice?.toString() ?? '0.00',             
          itemAmount.toFixed(2),                            
          item.quantity?.toString() ?? '0',                 
          '1',                                              
          itemAmount.toFixed(2),                           
          item.unitPrice?.toString() ?? '0.00',            
          "", // Warehouse (Items) - User to fill
          "", // Cost Center (Items) - User to fill
          "", // Expense Account (Items) - User to fill
        ];
        // Prepend the blank for credit_to
        csvString += [...invoiceLevelData.slice(0, 6), "", ...invoiceLevelData.slice(6), ...itemData].map(escapeCSVField).join(',') + '\n';
      });
    } else {
      const emptyItemData = Array(itemHeaders.length).fill(''); 
      csvString += [...invoiceLevelData.slice(0, 6), "", ...invoiceLevelData.slice(6), ...emptyItemData].map(escapeCSVField).join(',') + '\n';
    }
  });
  return csvString;
}


export function incomingInvoicesToJSON(invoices: IncomingInvoiceItem[] | ERPIncomingInvoiceItem[]): string {
  return JSON.stringify(invoices, null, 2);
}

function escapeTSVField(field: string | number | undefined | null): string {
  if (field === undefined || field === null) return '';
  return String(field).replace(/\t/g, ' ').replace(/\n/g, ' ').replace(/\r/g, ' ');
}

export function incomingInvoicesToTSV(invoices: IncomingInvoiceItem[] | ERPIncomingInvoiceItem[], erpMode: boolean): string {
  if (!invoices || invoices.length === 0) return '';
  let tsvString = '';

  if (erpMode) {
    const erpInvoices = invoices as ERPIncomingInvoiceItem[];
    const invoiceHeaders = [
        "supplier", "bill_no", "bill_date", "posting_date", "due_date", 
        "currency", /* "credit_to" removed */ "is_paid", "remarks", 
        "update_stock", "set_posting_time"
    ];
    const itemHeaders = [
        "ID (Items)", "Item Name (Items)", "Description (Items)", "Accepted Qty (Items)", "UOM (Items)",
        "Rate (Items)", "Amount (Items)", "Accepted Qty in Stock UOM (Items)", "UOM Conversion Factor (Items)",
        "Amount (Company Currency) (Items)", "Rate (Company Currency) (Items)",
        "Warehouse (Items)", "Cost Center (Items)", "Expense Account (Items)"
    ];
    const headers = [...invoiceHeaders, ...itemHeaders];
    tsvString = headers.map(h => escapeTSVField(h)).join('\t') + '\n';

    erpInvoices.forEach((invoice) => {
      const mainInvoiceData = [
        invoice.lieferantName,
        invoice.rechnungsnummer, 
        invoice.billDate,
        invoice.datum, 
        invoice.dueDate,
        invoice.wahrung || 'EUR',
        // credit_to removed
        invoice.istBezahlt?.toString() ?? '0',
        invoice.remarks,
        '1', 
        '1', 
      ];
      const mainInvoiceDataEscaped = mainInvoiceData.map(f => escapeTSVField(f));

      if (invoice.rechnungspositionen && invoice.rechnungspositionen.length > 0) {
        invoice.rechnungspositionen.forEach(item => {
          const itemAmount = (item.quantity || 0) * (item.unitPrice || 0);
          const itemData = [
            item.productCode,                 
            item.productName,                 
            item.productName,                 
            item.quantity.toString(),         
            "Stk",                            
            item.unitPrice.toString(),        
            itemAmount.toFixed(2),           
            item.quantity.toString(),         
            '1',                             
            itemAmount.toFixed(2),            
            item.unitPrice.toString(),       
            "", // Warehouse (Items)
            "", // Cost Center (Items)
            "", // Expense Account (Items)
          ];
          const itemDataEscaped = itemData.map(f => escapeTSVField(f));
          tsvString += [...mainInvoiceDataEscaped, ...itemDataEscaped].join('\t') + '\n';
        });
      } else {
        const emptyItemDataEscaped = Array(itemHeaders.length).fill('').map(f => escapeTSVField(f));
        tsvString += mainInvoiceDataEscaped.join('\t') + '\t' + emptyItemDataEscaped.join('\t') + '\n';
      }
    });
  } else { 
    const regularInvoices = invoices as IncomingInvoiceItem[];
    const mainHeaders = [
      'PDF Datei', 'Rechnungsnummer', 'Datum', 'Lieferant Name', 'Lieferant Adresse',
      'Zahlungsziel', 'Zahlungsart', 'Gesamtbetrag', 'MwSt-Satz', 'Kunden-Nr.', 'Bestell-Nr.'
    ];
    const itemHeaders = ['Pos. Produkt Code', 'Pos. Produkt Name', 'Pos. Menge', 'Pos. Einzelpreis'];
    tsvString = mainHeaders.map(h => escapeTSVField(h)).join('\t') + '\t' + itemHeaders.map(h => escapeTSVField(h)).join('\t') + '\n';

    regularInvoices.forEach((invoice) => {
      const mainInvoiceData = [
        escapeTSVField(invoice.pdfFileName),
        escapeTSVField(invoice.rechnungsnummer),
        escapeTSVField(invoice.datum),
        escapeTSVField(invoice.lieferantName),
        escapeTSVField(invoice.lieferantAdresse),
        escapeTSVField(invoice.zahlungsziel),
        escapeTSVField(invoice.zahlungsart),
        invoice.gesamtbetrag?.toString() ?? '',
        escapeTSVField(invoice.mwstSatz),
        escapeCSVField(invoice.kundenNummer),
        escapeCSVField(invoice.bestellNummer),
      ];

      if (invoice.rechnungspositionen && invoice.rechnungspositionen.length > 0) {
        invoice.rechnungspositionen.forEach(item => {
          const itemData = [
            escapeTSVField(item.productCode),
            escapeTSVField(item.productName),
            item.quantity.toString(),
            item.unitPrice.toString(),
          ];
          tsvString += mainInvoiceData.join('\t') + '\t' + itemData.join('\t') + '\n';
        });
      } else {
        const emptyItemData = Array(itemHeaders.length).fill('');
        tsvString += mainInvoiceData.join('\t') + '\t' + emptyItemData.join('\t') + '\n';
      }
    });
  }
  return tsvString;
}

export function erpInvoicesToSupplierCSV(invoices: ERPIncomingInvoiceItem[]): string {
  if (!invoices || invoices.length === 0) return '';

  const supplierHeaders = [
    "ID", // Usually blank for new suppliers, ERPNext assigns it
    "Supplier Name",
    "Supplier Type",
    "Supplier Group", // Changed from "Naming Series" for supplier context
    "Country",
    // "Supplier Group", // Duplicate, removed. Naming Series was likely misplaced here.
    "Is Transporter",
    "Image",
    "Default Currency",
    "Default Company Bank Account",
    "Default Price List",
    "Is Internal Supplier",
    "Represents Company",
    "Supplier Details",
    "Website",
    "Print Language",
    "Tax ID",
    "Tax Category",
    "Tax Withholding Category",
    "Primary Address", // Merged "Hauptadresse des Lieferanten" and "Hauptadresse"
    // "Hauptadresse", // Removed as it's covered by Primary Address
    "Primary Contact",
    "Mobile No",
    "Email ID",
    "Default Payment Terms Template",
    "Allow Purchase Invoice Creation Without Purchase Order",
    "Allow Purchase Invoice Creation Without Purchase Receipt",
    "Is On Hold", // Changed from "Ist gesperrt"
    "Disabled",
    "Warn on RFQs",
    "Warn on POs", // Purchase Orders
    "Prevent RFQs",
    "Prevent POs", // Purchase Orders
    "Block Supplier", // This seems like a status or a more permanent block
    "Hold Type",
    "Release Date", // For Hold Type
    "ID (Allowed to Transact With)",
    "Company (Allowed to Transact With)",
    "ID (Accounts)",
    "Default Account (Payable Account)", // Clarified
    "Company (Accounts)",
    "Advance Payment Account (Accounts)",
    "ID (Portal Users)",
    "User (Portal Users)"
  ];


  let csvString = supplierHeaders.map(escapeCSVField).join(',') + '\n';

  const uniqueSuppliers = new Map<string, ERPIncomingInvoiceItem>();
  invoices.forEach(invoice => {
    const supplierKey = (invoice.lieferantName || 'UNKNOWN_SUPPLIER').trim();
    if (supplierKey && !uniqueSuppliers.has(supplierKey)) {
      uniqueSuppliers.set(supplierKey, invoice);
    }
  });

  uniqueSuppliers.forEach(invoice => { 
    const supplierDataRow = [
      "", // ID (blank for new)
      escapeCSVField(invoice.lieferantName), // Supplier Name
      "Company", // Supplier Type (default)
      "All Supplier Groups", // Supplier Group (default)
      "Germany", // Country (default)
      // "All Supplier Groups", // Supplier Group (Removed duplicate)
      "No", // Is Transporter (default "No")
      "", // Image (empty)
      escapeCSVField(invoice.wahrung || "EUR"), // Default Currency
      "", // Default Company Bank Account (empty)
      "", // Default Price List (empty)
      "No", // Is Internal Supplier (default "No")
      "", // Represents Company (empty)
      "", // Supplier Details (empty)
      "", // Website (empty)
      "en", // Print Language (changed to "en" for English headers, can be "de")
      escapeCSVField(invoice.remarks?.includes("Tax ID:") ? invoice.remarks.split("Tax ID:")[1]?.split("/")[0]?.trim() : ""), // Attempt to extract Tax ID from remarks
      "", // Tax Category (empty)
      "", // Tax Withholding Category (empty)
      escapeCSVField(invoice.lieferantAdresse), // Primary Address
      // escapeCSVField(invoice.lieferantAdresse), // Hauptadresse (Removed)
      "", // Primary Contact (empty)
      "", // Mobile No (empty)
      "", // Email ID (empty)
      "", // Default Payment Terms Template (empty)
      "Yes", // Allow Purchase Invoice Creation Without Purchase Order (default "Yes")
      "Yes", // Allow Purchase Invoice Creation Without Purchase Receipt (default "Yes")
      "No", // Is On Hold (default "No")
      "No", // Disabled (default "No")
      "No", // Warn on RFQs (default "No")
      "No", // Warn on POs (default "No")
      "No", // Prevent RFQs (default "No")
      "No", // Prevent POs (default "No")
      "No", // Block Supplier (default "No" assuming this is a boolean)
      "", // Hold Type (empty)
      "", // Release Date (empty)
      "", // ID (Allowed to Transact With) (empty)
      "", // Company (Allowed to Transact With) (empty)
      "", // ID (Accounts) (empty)
      escapeCSVField(invoice.kontenrahmen), // Default Account (Payable Account)
      "", // Company (Accounts) (empty)
      "", // Advance Payment Account (Accounts) (empty)
      "", // ID (Portal Users) (empty)
      "", // User (Portal Users) (empty)
    ];
    csvString += supplierDataRow.map(escapeCSVField).join(',') + '\n';
  });

  return csvString;
}
